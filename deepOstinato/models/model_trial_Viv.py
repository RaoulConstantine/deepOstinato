import tensorflow as tf
from tensorflow.keras import Sequential, layers
import numpy as np

from keras.layers import Input, Dense, Reshape, Flatten, Dropout
#from keras.layers import BatchNormalization, Activation, ZeroPadding2D
from keras.layers.convolutional import Conv2D
from keras.models import Sequential, Model
#from keras.optimizers import Adam

class GAN():
    def __init__(self):
        """Spectrogram dimensions"""
        self.spec_rows = 28
        self.spec_cols = 28
        self.channels = 1
        self.spec_shape = (self.spec_rows, self.spec_cols, self.channels)

        # Build and compile the discriminator
        self.discriminator = self.build_discriminator()
        self.discriminator.compile(loss='binary_crossentropy',
                                                optimizer="Adam",
                                                metrics=['accuracy'])

        # Build and compile the generator
        self.generator = self.build_generator()
        self.generator.compile(loss='binary_crossentropy', optimizer="Adam")

        # Spectrograms generated by Generator with random input
        self.generator_input = Input(shape=(100,))
        spec = self.generator(self.generator_input)

        # Switch to turn on or off the training of the discriminator
        self.discriminator.trainable = False
        valid = self.discriminator(spec) #discriminator prediction

        # GAN model  (stacked generator and discriminator), optimized on the discriminator validity check
        self.combined = Model(self.generator_input, valid)
        self.combined.compile(loss='binary_crossentropy', optimizer="Adam")

    def build_generator(self):

        noise_shape = self.generator_input.shape

        model = Sequential([
                        layers.Dense(self.spec_rows*self.spec_cols*self.channels, input_shape=noise_shape),
                        layers.Reshape([self.spec_rows,self.spec_cols,self.channels]),
                        layers.Conv2DTranspose(32, kernel_size = 3, strides =2, padding = 'same',activation = 'relu'),
                        layers.Conv2DTranspose(1, kernel_size = 3, strides =2, padding = 'same',activation = 'relu')
        ])

        noise = Input(shape=noise_shape)
        spec = model(noise)

        return Model(noise, spec)

    def build_discriminator(self):

        spec_shape = (self.spec_rows, self.spec_cols, self.channels)

        model = Sequential([
            layers.Conv2D(64, kernel_size = 5, strides =2, padding = 'same' ,activation = 'relu'),
            layers.MaxPooling2D(pool_size=(2,2)),
            layers.Dropout(0.4),
            layers.Conv2D(64, kernel_size = 5, strides =2, padding = 'same' ,activation = 'relu'),
            layers.Dropout(0.4),
            layers.Flatten(),
            layers.Dense(1, activation = 'sigmoid')
        ])

        #COME BACK TO UPDATE INPUTS

        spec = Input(shape=spec_shape)
        validity = model(spec)

        return Model(spec, validity)

    def train(self, epochs, batch_size=128, save_interval=50):

        # Load the dataset


        # Preprocessing


        for epoch in range(epochs):

            # Select a random "real" spectrograms

            real_specs = 0 #Placeholder ---> load()

            #---load method

            # Generate a new spectrograms
            #generated_specs = self.generator.predict(noise)

            # Train the discriminator

            # Train the generator


if __name__ == '__main__':
    gan = GAN()
    gan.train(epochs=30000, batch_size=32, save_interval=200)
